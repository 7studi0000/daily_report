# useCallback 学習メモ

## 1. わかったこと（核心的な理解）

### 🔸 関数の再生成問題

Reactでは、親コンポーネントが再レンダリングされるたびに、その中で定義された関数（例：`handleClick`）は毎回新しく再生成される。この新しい関数がPropsとして子コンポーネントに渡されると、子コンポーネントは「Propsが変更された」と判断し、不要な再レンダリングを引き起こしてしまう。

### 🔸 useCallbackの役割

`useCallback`は、関数そのものをメモ化（記憶）するためのフックである。このフックを使うと、関数の参照先が固定され、親コンポーネントが再レンダリングされても、子コンポーネントに渡されるProps（関数）は「変わっていない」と見なされる。

### 🔸 memoとの併用（最適化の鉄則）

パフォーマンスを向上させるには、以下の併用が必須である。

- **子コンポーネントを`memo`でラップする**：Propsが変わらない限り再レンダリングを阻止する。
- **渡す関数を`useCallback`でメモ化する**：memo化された子コンポーネントが「Propsが変わった」と誤認しないように、関数参照の変更を防ぐ。

### 🔸 依存配列の重要性（クロージャ対策）

`useCallback`内の関数でstateやpropsの値を使用する場合、その値を必ず依存配列（`[]`）に含める必要がある。これを含めないと、関数は最初のレンダリング時の古い値（クロージャ）を参照し続けてしまい、ロジックが破綻する。

---

## 2. 次やること（自力で発見する課題）

今回の知識を応用し、更なるパフォーマンス最適化に挑む。

- **useMemoの学習**：`useCallback`が関数をメモ化するのに対し、「計算結果の値」をメモ化する`useMemo`フックの学習に進む。描画コストの高い値の再計算を防ぐ方法を習得する。
- **使いどころの見極め**：`useCallback`や`memo`を使いすぎると、それらのフックが動作するコスト（オーバーヘッド）が、最適化によって得られる効果を上回ることがある。次に、これらを使うべき適切な条件（例えば、子コンポーネントの描画コストが高い場合など）を見極める方法を調査する。

---

## 3. 感想（内省）

`useState`やpropsの変更が、目に見えないところで関数の再生成を引き起こしていることが分かった。特に、**「計算コストの高い子コンポーネント」と「関数Props」** が組み合わさる場面で、`useCallback`と`memo`が性能維持にいかに重要であるかを理解できた。次に`useMemo`を学び、パフォーマンス最適化の知識を完全なものにしたい。

Total：73h