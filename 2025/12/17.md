## 🎓 学習テーマ

1. **`useMemo` による計算結果の保持**
2. **コンポーネントの動的ロード（パフォーマンス向上）**
3. **React Router 入門：画面遷移の実装**

---

### 1. わかったこと (核心的な理解)

#### 🔸 `useMemo` と `useCallback` の明確な使い分け

* **`useMemo`（値のメモ化）**: 巨大な配列のフィルタリングやソートなど、**「計算コストの高い処理の結果（値）」** を保持するために使用する。依存配列の値が変わらない限り、再レンダリング時に計算をスキップできる。
* **`useCallback`（関数のメモ化）**: **「関数そのもの」** を保持するために使用する。子コンポーネントにPropsとして関数を渡す際、関数の再生成を防いで `React.memo` の効果を維持するために必須となる。

#### 🔸 コンポーネントの最適化

* **`React.memo`**: コンポーネント自体をラップし、Propsが変わらない限り再描画しないようにする。
* **動的ロード (Dynamic Load)**: 全てのコンポーネントを一度に読み込むのではなく、必要になったタイミングでロードすることで、アプリの初期表示速度を高速化できる。

#### 🔸 React Router による画面遷移

* SPA（シングルページアプリケーション）において、ブラウザをリロードせずに URL に応じた表示の切り替えを行う方法を習得した。
* ルーティングを設定することで、ユーザー体験を損なわないスムーズな画面遷移が可能になる。

---

### 2. 本日の課題への回答

提示された「巨大な配列を処理する」シナリオの回答です。

1. **処理 A（抽出されたデータ）**: **`useMemo`** を使用すべきです。
* **理由**: 配列の抽出は「計算処理」であり、その「結果（値）」を再利用したいため。`useMemo` を使うことで、親が再描画されても配列が変化しない限り、重いフィルタリング処理をスキップできます。


2. **処理 B（ボタンの実行関数）**: **`useCallback`** を使用すべきです。
* **理由**: ボタンの操作は「振る舞い（関数）」であり、子コンポーネントが `React.memo` で最適化されている場合、関数の再生成を防がないと不要な再描画が発生するためです。



---

### 3. 感想 (内省)

今日の学習で、React がなぜ高速に動作するのか、そして開発者がどうすればさらに効率的なアプリを作れるのか、その「仕組み」への理解が深まりました。特に、重い処理がある環境で `useMemo` を使った際に入力遅延が解消される様子は、最適化の重要性を実感する体験でした。

今後は、これらの最適化を「いつ、どこで使うべきか（使いすぎない判断）」を意識しながら、学んだ React Router を使ってより実践的な複数画面のアプリ制作に挑戦していきたいです。

---

Total：73h